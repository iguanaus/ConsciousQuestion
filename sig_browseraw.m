function sig_browseraw(datamatrix,varargin)
% function sig_browseraw(datamatrix,varargin)
% sig_browseraw() - browse raw data
%
% sig_browseraw is a raw data browser with support for Neuromag fif format
%
% Usage: 
%  sig_browseraw(datafile, 'key1', value1 ...); % read from data file
%
% Display window interface:
%  "Activity plot" - [main window] This axis displays the channel activities.
%       For continuous data, the time axis shows time in seconds.
%  "Close" - [button] Closes the window and cancels any data rejection marks.
%  "Event types" - [button] pop up a legend window for events.
%  "<<" - [button] Scroll backwards though time by one window length.
%  "<"  - [button] Scroll backwards though time by 0.2 window length.
%  "Navigation edit box" - [edit box] Enter a starting time or epoch to jump to.
%  ">"  - [button] Scroll forward though time by 0.2 window length.
%  ">>" - [button] Scroll forward though time by one window length.
%  "Chan/Time/Value" - [text] If the mouse is within the activity window,
%       indicates to which channel, time, and activity value the cursor is
%       closest.
%  "Scale edit box" - [edit box] Scales the displayed amplitude in activity
%       units.  Command line equivalent: 'spacing' 
%  "+ / -" - [buttons] Use these buttons to +/- the amplitude scale by 10%. 
%  "Save" - [button] When pressed, save events (including rejection marks
%     and manual events).
%  "Clear" - [button] When pressed, clear manual rejection marks
%     and manual events from current window
% Required input:
%  datafile - full or relative pathname of raw data file
% Optional keywords:
%  'outfile' - output file name for mat file containing saved events
%     { default: "savedevents.mat" }
%  'readevents' - ['on'|'off'] Toggle read events from raw data
%     file.  Will also read header and get length of data file.
%     Makes prereadeof irrelevant.
%     { default: 'off'}
%  'prereadeof' - ['on'|'off'] Toggle get length of data file by reading
%     entire file (time consuming). Otherwise, risk core dump if you try
%     to jump past end of file.  Continuous browsing is safe either way.
%     Parameter is ignored if hdr is supplied or if readevents = on
%    { default: 'off' }
%  'events'     - [struct] event structure with the following fields:
%     events.type      = string (e.g. trigger, skip, reject, manual)
%     events.latency   = expressed in samples, first sample of file is 1
%     events.condition = numeric event code
%     events.duration  = expressed in samples
%  'hdr'        - [struct] hdr structure (see sig_read_header)
%     hdr.sfreq           sampling frequency
%     hdr.nChans          number of channels
%     hdr.nSamples        number of samples per buffer
%     hdr.skips           vector of sample latencies for "skips"
%     hdr.tfirst          first time point in file
%     hdr.tlast           last time point in file
%     hdr.nBuffs          number of buffers in file (not including skips)
%     hdr.sensors         structure containing sensor information
%     if supplied, header will not be read from datafile unless readevents = 1
%  'minchan'    - first channel number to read
%     { default: 1 }
%  'maxchan'    - last channel number to read
%     { default: inf }
%  'badchans'   - vector of channel numbers to exclude
%                 from display and artifact rejection
%     { default: [] }
%  'read_lfp' - ['on'|'off'] Toggle reading lfp channels (if in file)
%     { default: 'on' }
%  'read_eeg'   - ['on'|'off'] Toggle reading eeg channels (if in file)
%     { default: 'on' }
%  'scale_lfp' - scale factor applied to lfp data
%     the scaling controled by scale_lfp is applied after this
%     { default: 1 }
%  'scale_eeg' - scale factor applied to EEG data
%     eeg data is prescaled by 10^6 into uV
%     the scaling controled by scale_eeg is applied after this
%     { default: 5 }
%  'autoreject'  - ['on'|'off'] Toggle automatic artifact rejection
%     { default: 'on' }
%  'reject_lfp' - automatic rejection threshold for lfp channels 
%     if 0, rejection based on eeg is disabled
%     { default: 0 }
%  'reject_eeg' - automatic rejection threshold for eeg channels (uV)
%     if 0, rejection based on eeg is disabled
%     { default: 0 }
%  'prestim_dur' - duration of prestimulus period (msec)
%     used for displaying automatic artifact rejection
%     { default: 100 }
%  'poststim_dur' - duration of poststimulus period (msec)
%     used for displaying automatic artifact rejection
%     { default: 300 }
%  'filter'         - ['on'|'off'] Toggle bandpass frequency filter
%     { default: 'off' }
%  'filter_low_cf'  - low cutoff frequency (high-pass filter) (Hz)
%     { default: 0.2 }
%  'filter_low_tb'  - low cutoff transition band (Hz)
%     { default: 0 }
%  'filter_high_cf' - high cutoff frequency (low-pass filter) (Hz)
%     { default: 100 }
%  'filter_high_tb' - high cutoff transition band (Hz)
%     { default: 0 }
%  'spacing'    - Display range per channel (default|0: max(data)-min(data))
%  'winlength'  - [value] Seconds of data to display in window {default: 5}
%  'dispchans'  - [integer] Number of channels to display in the activity window
%     {default: all}.  If < total number of channels, a vertical slider
%     on the left side of the figure allows vertical data scrolling.
%  'chanlabels' - ['on'|'off'] Toggle display of channel labels (or just numbers)
%     {default: 'off'}
%  'xgrid'      - ['on'|'off'] Toggle display of the x-axis grid
%     {default: 'off'}
%  'ygrid'      - ['on'|'off'] Toggle display of the y-axis grid
%     {default: 'off'}
%  'ploteventdur' - ['on'|'off'] Toggle display of event duration
%     { default: 'on' }
%  'color'      - ['on'|'off'|cell array] Plot channels with different colors.
%     Entering a RGB cell array {'r' 'b' 'g'}, channels will be plotted using
%     the cell-array color elements. {default: 'off'}. 
%  'wincolor'   - [color] Color mark data stretches  
%                 {default: [ 0.8345 1 0.956]}
%  'submean'    - ['on'|'off'] Remove channel means in each window
%     {default: 'on'}
%  'position'   - [lowleft_x lowleft_y width height] Position of the figure in
%     pixels.
%  'tag'        - [string] Matlab object tag to identify this sig_browseraw()
%     window (allows keeping track of several simultaneous sig_browseraw() windows). 
%  'children'   - [integer] Figure handle of a *dependent* sig_browseraw() window.
%     Scrolling horizontally in the master window will produce the same
%     scroll in the dependent window. Allows comparison of two concurrent
%     datasets.
%  'scale'      - ['on'|'off'] Display the amplitude scale {default: 'on'}.
% Outputs:
%  savedevents  -  Event structure (same format as 'events' above) created
%     when the SAVE button is clicked. 
%
% Author of sig_browseraw: Nima Dehghani , Laboratory of Computational neuroscience, UNIC-CNRS, 
% v1: Nov 28th 2011 
% Modified: Nov 30th online filter added
% Modified: Dec 1 2011; spacing fixed
% Modified: Dec 4th 2011; second modality added
%% todo: scan through file (autoadvance)
%% todo: rereference (i.e. bipolar)
%% todo: finish the ts_read_event and ts_read_header
%%
%% EXAMPLE
% load data
% load MG29_20090215-173256-006_LFP
% %% set the headers
% chanList=1:58;
% hdr.sfreq = 1250;
% hdr.nChans = length(chanList);
% hdr.sensors.typestring= cell(1,length(chanList))
% for i=1:length(chanList)
%    hdr.sensors.typestring(i)={'lfp'}; 
% end
% hdr.tfirst =  0;
% hdr.tlast = length(Mtx)/hdr.sfreq;

% %% launch sig_browseraw
% sig_browseraw(Mtx,'read_lfp','on','autoreject','off','submean','off','hdr',hdr)
% ---------------------------------------------------------------------- 


DEFAULT_PLOT_COLOR = { [0 0 1], [0.7 0.7 0.7]};         % EEG line color
DEFAULT_FIG_COLOR = [0.6 0.6 0.6];
BUTTON_COLOR =[0.8 0.8 0.8];
DEFAULT_LINE_COLOR = [0 0 0];     % vertical line color
DEFAULT_AXIS_COLOR = 'k';         % X-axis, Y-axis Color, text Color
DEFAULT_GRID_SPACING = 1;         % Grid lines every n seconds
DEFAULT_GRID_STYLE = '-';         % Grid line style
YAXIS_NEG = 'off';                % 'off' = positive up 
SPACING_UNITS_STRING = '';        % '\muV' for microvolt optional units for g.spacingI Ex. uV
%DEFAULT_AXES_POSITION = [0.07 0.09 0.62  0.87]; % dimensions of main EEG axes
DEFAULT_AXES_POSITION = [0.07 0.09 0.62  0.87]; % dimensions of main EEG axes
LABELS_AXES_POSITION =  [0.12 0.09 0.57  0.87];
ORIGINAL_POSITION = [150 250 800 500];
PRESCALE_LFP = 1;%
PRESCALE_EEG = 1;%
DEFAULT_SCALE_LFP = 5;
DEFAULT_SCALE_EEG = 5;
MAX_WINLENGTH = 20; % seconds

if nargin < 1
   help(mfilename);
   return
end
                  
% %%%%%%%%%%%%%%%%%%%%%%%%
% Setup inputs
% %%%%%%%%%%%%%%%%%%%%%%%%

callbacks = {'drawp' 'drawb' 'draws' 'updateevents' 'initevents'...
             'setchanlabels' 'zoom' 'updateslider' 'drawlegend' 'readfile'...
             'clearmanual' 'sortevents' 'clearrejects' 'findartifacts'...
             'scaledata' 'filterdata'...
             'setreadchans' 'mouseclickdown' 'mousemove'};

%if ~ismember(datamatrix,callbacks)    
if ~isstr(datamatrix)
  if(isempty(datamatrix))
    fprintf('%s: datamatrix %s not found\n',mfilename,datamatrix);
    return;
  end
  try
    options = varargin;
    for index = 1:length(options)
        if iscell(options{index}) & ~iscell(options{index}{1}), options{index} = { options{index} }; end;
    end;
    if ~isempty( varargin ), g=struct(options{:}); 
    else g= []; end;
  catch
    fprintf('%s: calling convention {''key'', value, ... } error',mfilename);
    return;
  end;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Set defaults or override with user arguments
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  try g.title;           catch, g.title        = ['Browse Raw Data']; end;
  try g.outfile;         catch, g.outfile      = 'savedevents.mat'; end;
  try g.spacing;         catch, g.spacing      = 0;     end;
  try g.position;        catch, g.position     = ORIGINAL_POSITION; end;
  try g.tag;             catch, g.tag          = mfilename; end;
  try g.showlabels;      catch, g.showlabels   = 'off'; end;
  try g.xgrid;           catch, g.xgrid        = 'off'; end;
  try g.ygrid;           catch, g.ygrid        = 'off'; end;
  try g.color;           catch, g.color        = 'off'; end;
  try g.submean;         catch, g.submean      = 'on';  end;
  try g.children;        catch, g.children     = 0;     end;
  try g.wincolor;        catch, g.wincolor     = [ 0.8345 1 0.9560]; end;
  try g.scale;           catch, g.scale        = 'on';  end;
  try g.readevents;      catch, g.readevents   = 'off'; end;
  try g.events;          catch, g.events       = [];    end;
  try g.ploteventdur;    catch, g.ploteventdur = 'on';  end;
  try g.minchan;         catch, g.minchan      = 0;     end;
  try g.maxchan;         catch, g.maxchan      = inf;   end;
  try g.badchans;        catch, g.badchans     = [];    end;
  try g.dispchans;       catch, g.dispchans    = 20;    end;
  try g.prereadeof;      catch, g.prereadeof   = 'off'; end;
  try g.hdr;             catch, g.hdr          = [];    end;
  try g.read_lfp;        catch, g.read_lfp     = 'on';  end;
  try g.read_eeg;        catch, g.read_eeg     = 'on';  end;
  try g.scale_lfp;       catch, g.scale_lfp    = DEFAULT_SCALE_LFP;  end;
  try g.scale_eeg;       catch, g.scale_eeg    = DEFAULT_SCALE_EEG;  end;
  try g.autoreject;      catch, g.autoreject   = 'on';  end;
  try g.reject_lfp;      catch, g.reject_lfp   = 0;     end;
  try g.reject_eeg;      catch, g.reject_eeg   = 0;     end;
  try g.prestim_dur;     catch, g.prestim_dur  = 100;   end;
  try g.poststim_dur;    catch, g.poststim_dur = 300;   end;
  try g.filter;          catch, g.filter       = 'off'; end;
  try g.filter_low_cf;   catch, g.filter_low_cf  = 0.2;  end;
  try g.filter_low_tb;   catch, g.filter_low_tb  = 0;    end;
  try g.filter_high_cf;  catch, g.filter_high_cf = 100;  end;
  try g.filter_high_tb;  catch, g.filter_high_tb = 0;    end;
  try g.winlength; catch, g.winlength = 5; end;
  try g.hdr; catch, g.hdr=[];end;

  gfields = fieldnames(g);
  for index=1:length(gfields)
     switch gfields{index}
     case {'title' 'outfile' 'spacing' 'winlength' 'position' ...
           'command' 'tag' 'showlabels' 'xgrid' 'ygrid' 'color' ...
           'submean' 'children' 'limits' 'dispchans' 'wincolor' ...
           'ploteventdur' 'butlabel' 'scale' 'events' ...
           'minchan' 'maxchan' 'badchans' 'readevents' 'prereadeof' 'hdr'...
           'read_lfp' 'scale_lfp' ...
           'read_eeg' 'scale_eeg' ...
           'autoreject' 'reject_lfp' 'reject_eeg' ...
           'prestim_dur' 'poststim_dur' 'filter' 'filter_low_cf'...
           'filter_low_tb' 'filter_high_cf' 'filter_high_tb'},
     otherwise, error([mfilename ': unrecognized option: ''' gfields{index} '''' ]);
     end;
  end;

  % change from string to boolean
  if strcmpi(g.showlabels, 'on'),   g.showlabels = 1;   else g.showlabels = 0; end;
  if strcmpi(g.prereadeof, 'on'),   g.prereadeof = 1;   else g.prereadeof = 0; end;
  if strcmpi(g.readevents, 'on'),   g.readevents = 1;   else g.readevents = 0; end;
  if strcmpi(g.read_lfp,'on'),      g.read_lfp = 1;     else g.read_lfp = 0; end;
  if strcmpi(g.read_eeg,'on'),      g.read_eeg = 1;     else g.read_eeg = 0; end;
  if strcmpi(g.filter, 'on'),       g.filter = 1;       else g.filter = 0;       end;
  if strcmpi(g.ploteventdur, 'on'), g.ploteventdur = 1; else g.ploteventdur = 0; end;
  if strcmpi(g.autoreject, 'on'),   g.autoreject = 1;   else g.autoreject = 0;   end;
  if strcmpi(g.xgrid, 'on'),        g.xgrid = 1;        else g.xgrid = 0;   end;
  if strcmpi(g.ygrid, 'on'),        g.ygrid = 1;        else g.ygrid = 0;   end;
  if strcmpi(g.submean, 'on'),      g.submean = 1;      else g.submean = 0;   end;

  % reject bad parameters
  strlen = length(g.outfile);
  if ~strcmp('.mat',g.outfile(strlen-3:strlen))
    g.outfile = [g.outfile '.mat'];
  end;
  if length(g.spacing) > 1
    disp('Error: ''spacing'' must be a single number'); return;
  end;    
  if length(g.dispchans) > 1
    disp('Error: ''dispchans'' must be a single number'); return;
  end;    
  if length(g.winlength) > 1
    disp('Error: winlength must be a single number'); return;
  end;    
  if isstr(g.tag) > 1
    disp('Error: tag must be is a string'); return;
  end;    
  if length(g.position) ~= 4
    disp('Error: position must be is a 4 elements array'); return;
  end;    
  switch lower(g.scale)
    case { 'on' 'off' };
    otherwise disp('Error: scale must be either ''on'' or ''off'''); return;
  end;    
  if ~iscell(g.color)
    switch lower(g.color)
    case 'on', g.color = { 'k', 'm', 'c', 'b', 'g' }; 
    case 'off', g.color = { [ 0 0 0.4] };  
    otherwise 
      disp('Error: color must be either ''on'' or ''off'' or a cell array'); return;
    end;    
  end;

  % load header
  g.datamatrix = datamatrix;
  % winlength = seconds of data read and displayed
  g.maxwinlength = MAX_WINLENGTH;
  g.rawbegtime = 0;
  g.rawendtime = g.rawbegtime + g.winlength;
  if(g.readevents)
    fprintf('reading events for %s...\n',gdatamatrix);
  %  [g.hdr,tmpevents]=ts_read_events(g.datamatrix); %???
    g.events = [g.events,tmpevents];
  elseif(isempty(g.hdr))
    fprintf('reading header for %s...\n',g.datamatrix);
    if(g.prereadeof)
      fprintf('this may take awhile...\n',g.datamatrix);
   %   g.hdr = ts_read_header(g.datamatrix,1);  %???
    else
      fprintf('not getting file length (prereadeof = off), so be careful!\n');
    %  g.hdr = ts_read_header(g.datamatrix,0); %???
    end
  end

  g.srate = g.hdr.sfreq;
  g.frames = round(g.winlength*g.srate);
  g.prestim_samp  = round(g.prestim_dur  * g.srate/1000); % convert from msec to samples
  g.poststim_samp = round(g.poststim_dur * g.srate/1000); % convert from msec to samples
  g.winstatus = 1;
  g.setchannel  = 0;
  g.chanoffset = 0;
  g.plotevent = 1;
  g.manual_reject = 1;
  g.manual_event = 0;
  g.manual_event_code = 1;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Prepare figure and axes
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  figh = figure('UserData', g,... % store the settings here
     'Color',DEFAULT_FIG_COLOR, 'name', g.title, ...
     'MenuBar','none','tag', g.tag ,'Position',g.position,...
     'numbertitle', 'off', 'visible', 'off');

  % set channels for reading
  sig_browseraw('setreadchans');
  g = get(figh,'UserData');

  pos = get(figh,'position'); % plot relative to current axes
  q = [pos(1) pos(2) 0 0];
  s = [pos(3) pos(4) pos(3) pos(4)]./100;
  clf;

  % Background axis
  % --------------- 
  ax0 = axes('tag','UI_backaxis','parent',figh,...
     'Position',DEFAULT_AXES_POSITION,...
     'Box','off','xgrid','off', 'xaxislocation', 'top'); 

  % Data axis
  % --------------- 
  YLabels = num2str(g.readchans'); % use chan numbers by default
  YLabels = flipud(str2mat(YLabels,' '));
  data = zeros(g.chans,g.frames);
  ax1 = axes('Position',DEFAULT_AXES_POSITION,...
     'userdata', data, ...% store the data here (when in g, slow down display)
     'tag','UI_dataaxis','parent',figh,...
     'Box','on','xgrid', fastif(g.xgrid,'on','off'),...
     'ygrid', fastif(g.ygrid,'on','off'),...
     'gridlinestyle',DEFAULT_GRID_STYLE,...
     'Xlim',[0 g.winlength*g.srate],...
     'xtick',[0:g.srate*DEFAULT_GRID_SPACING:g.winlength*g.srate],...
     'Ylim',[0 (g.chans+1)],...
     'YTick',[0:1:g.chans],...
     'YTickLabel', YLabels,...
     'XTickLabel',num2str((0:DEFAULT_GRID_SPACING:g.winlength)'),...
     'TickLength',[.005 .005],...
     'Color','none',...
     'XColor',DEFAULT_AXIS_COLOR,...
     'YColor',DEFAULT_AXIS_COLOR);

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Set up uicontrols
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % lower left corners of uicontrol groups
  ui_slider      = [0.02,DEFAULT_AXES_POSITION(2)];
  ui_buttons     = [0.70,0.02];
  ui_timestep    = [0.2,0.0];
  ui_spacing     = [0.70,0.2];
  ui_value       = [0.83,0.0];
  ui_filter      = [0.83,0.13];
  ui_autoreject  = [0.83,0.34];
  ui_scale       = [0.94,0.34];
  ui_read        = [0.83,0.55];
  ui_display     = [0.83,0.74];
  ui_manual      = [0.70,0.74];

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Slider for vertical motion
  ui_offset = ui_slider;

  % set positions
  n=1;
  uipos(n,:)  = [ 0.0 0.0 0.015 DEFAULT_AXES_POSITION(4) ]; n=n+1; % slider
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);
  
  % define commands
  slider_cmd = [...
    'tmpg = get(gcbf, ''userdata'');' ... 
    'tmpg.chanoffset = get(gcbo, ''value'')*(tmpg.chans-tmpg.actualdispchans);' ...
    'set(gcbf, ''userdata'', tmpg);' ...
    'sig_browseraw(''drawp'',0);' ...
    'clear tmpg;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Style','slider', ...
   'visible', 'off', ...
   'sliderstep', [0.9 1], ...
   'Tag','UI_slider', ...
   'callback',slider_cmd,...
   'value', 0);

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % buttons group
  ui_offset = ui_buttons;

  % set positions
  n=1;
  uipos(n,:)  = [ 0.01       0.01      0.09     0.05   ]; n=n+1; % close
  uipos(n,:)  = [ 0.01       0.68      0.09     0.05   ]; n=n+1; % event types
  uipos(n,:)  = [ 0.01       0.60      0.09     0.05   ]; n=n+1; % save events
  uipos(n,:)  = [ 0.01       0.52      0.09     0.05   ]; n=n+1; % clear
  uipos(n,:)  = [ 0.01       0.44      0.09     0.05   ]; n=n+1; % reject
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  close_cmd = [...
    'g = get(gcbf, ''userdata'');'... 
    'if g.children, delete(g.children); end;'...
    'close(gcbf);'...
  ];
  save_cmd = [...
    'sig_browseraw(''clearrejects'');'...
    'sig_browseraw(''sortevents'');'...
    'g = get(gcbf, ''userdata'');'...
    'keep = find(cell2mat({g.events.duration})~=0);'...
    'g.events = g.events(keep);'...
    'savedevents = g.events;'...
    'save(g.outfile, ''savedevents'');'...
    'set(gcbf,''userdata'', g);' ...
    'sig_browseraw(''initevents'');'...
    'sig_browseraw(''findartifacts'');'...
  ];
  reject_cmd = [...
    'g = get(gcbf, ''userdata'');' ...
    'tmp_beg_samp = g.rawbegtime*g.srate + 1;'...
    'tmp_end_samp = g.rawendtime*g.srate;'...
    'g.events(end+1).type = ''reject'';'...
    'g.events(end  ).latency = tmp_beg_samp;'...
    'g.events(end  ).condition = 0;'...
    'g.events(end  ).duration = tmp_end_samp - tmp_beg_samp;'...
    'g.tmpevent.latency=0;'...
    'g.tmpevent.duration=0;'...
    'set(gcbf,''UserData'', g);' ...
    'sig_browseraw(''updateevents'');'...
    'sig_browseraw(''drawb'');'...
    'clear tmp_beg_samp tmp_end_samp;'...
  ];
  clear_cmd = [...
    'sig_browseraw(''clearmanual'');'...
    'sig_browseraw(''updateevents'');'...
    'sig_browseraw(''drawb'');'...
  ];

  % create uicontrols
  n=1;
  % close button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_close',...
   'string','CLOSE',...
   'callback', close_cmd);
  n=n+1;
  % events button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_events',...
   'TooltipString','Display event type legend',...
   'string', 'Legend',...
   'callback', 'sig_browseraw(''drawlegend'', gcbf)');
  n=n+1;
  % save events button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_save',...
   'TooltipString','Save events and rejects',...
   'string','Save',...
   'callback', save_cmd);
  n=n+1;
  % clear manual button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_clear',...
   'TooltipString','Clear manual rejects and events for current epoch',...
   'string','Clear',...
   'callback', clear_cmd);
  n=n+1;
  % reject button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_reject',...
   'TooltipString','Reject current epoch',...
   'string','Reject',...
   'callback', reject_cmd);
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % timestep group
  ui_offset = ui_timestep;

  % set positions
  n=1;
  uipos(n,:)  = [ 0.00      0.01    0.0385    0.039 ]; n=n+1; % <<
  uipos(n,:)  = [ 0.04      0.01    0.0288    0.039 ]; n=n+1; % <
  uipos(n,:)  = [ 0.0705    0.01    0.0561    0.039 ]; n=n+1; % Eposition
  uipos(n,:)  = [ 0.13      0.01    0.0299    0.039 ]; n=n+1; % >
  uipos(n,:)  = [ 0.16      0.01    0.0385    0.039 ]; n=n+1; % >>
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);
  
  % create uicontrols
  n=1;
  % Five move buttons: << < text > >> 
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_jumpback',...
   'TooltipString','jump back',...
   'string','<<',...
   'Callback','sig_browseraw(''drawp'',1)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_stepback',...
   'TooltipString','step back',...
   'string','<',...
   'Callback','sig_browseraw(''drawp'',2)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_position',...
   'TooltipString','select time',...
   'string', 0,...
   'Callback', 'sig_browseraw(''drawp'',0);' );
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_stepforward',...
   'TooltipString','step forward',...
   'string','>',...
   'Callback','sig_browseraw(''drawp'',3)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_jumpforward',...
   'TooltipString','jump forward',...
   'string','>>',...
   'Callback','sig_browseraw(''drawp'',4)');

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % read group
  ui_offset = ui_read;

  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.13      0.08      0.039  ]; n=n+1; % read_lfp
  uipos(n,:) = [ 0.00      0.09      0.08      0.039  ]; n=n+1; % read_eeg
  uipos(n,:) = [ 0.00      0.005     0.04      0.039  ]; n=n+1; % min_chan label
  uipos(n,:) = [ 0.04      0.01      0.04      0.039  ]; n=n+1; % min_chan
  uipos(n,:) = [ 0.08      0.005     0.04      0.039  ]; n=n+1; % max_chan label
  uipos(n,:) = [ 0.12      0.01      0.04      0.039  ]; n=n+1; % max_chan
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  read_cmd = [ ...
    'g = get(gcbf, ''userdata'');' ...
    'g.read_lfp   = get(findobj(gcbf, ''tag'', ''UI_read_lfp''),''value'');'...
    'g.read_eeg   = get(findobj(gcbf, ''tag'', ''UI_read_eeg''),''value'');'...
    'tmp_minchan  = str2num(get(findobj(gcbf, ''tag'', ''UI_minchan''),''string''));'...
    'tmp_maxchan  = str2num(get(findobj(gcbf, ''tag'', ''UI_maxchan''),''string''));'...
    'if size(tmp_minchan)==1 & tmp_minchan>0'...
    '  g.minchan = round(tmp_minchan);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_minchan''),''string'',num2str(g.minchan));'...
    'if size(tmp_maxchan)==1 & tmp_maxchan>0'...
    '  g.maxchan = round(tmp_maxchan);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_maxchan''),''string'',num2str(g.maxchan));'...
    'set(gcbf, ''userdata'', g);' ...
    'sig_browseraw(''setreadchans'');'...
    'sig_browseraw(''setchanlabels'');'...
    'sig_browseraw(''readfile'');'...
    'sig_browseraw(''updateevents'');'...
    'sig_browseraw(''updateslider'', gcbf);'...
    'sig_browseraw(''drawp'',0);'...
    'clear tmp_minchan tmp_maxchan;'...
  ];
  
  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_read_lfp',...
   'TooltipString','read LFP channels',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'value', g.read_lfp,...
   'string','LFP');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_read_eeg',...
   'TooltipString','read EEG channels',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'value', g.read_eeg,...
   'string','EEG');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_minchan_label',...
   'HorizontalAlignment', 'left',...
   'string','min');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_minchan',...
   'TooltipString','minimum channel number to read',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'string',num2str(g.minchan));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_maxchan_label',...
   'HorizontalAlignment', 'left',...
   'string','max');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_maxchan',...
   'TooltipString','maximum channel number to read',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'string',num2str(g.maxchan));
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % autoreject group
  ui_offset = ui_autoreject;

  % set positions
  n=1;
  uipos(n,:) = [ 0.0       0.16      0.11      0.039  ]; n=n+1; % autoreject
  uipos(n,:) = [ 0.042     0.12      0.05      0.039  ]; n=n+1; % reject_lfp
  uipos(n,:) = [ 0.042     0.08      0.05      0.039  ]; n=n+1; % reject_eeg
  uipos(n,:) = [ 0.0       0.12      0.042     0.031  ]; n=n+1; % reject_lfp label
  uipos(n,:) = [ 0.0       0.08      0.042     0.031  ]; n=n+1; % reject_eeg label
  uipos(n,:) = [ 0.00     -0.04      0.035     0.031  ]; n=n+1; % prestim_dur label
  uipos(n,:) = [ 0.03     -0.04      0.045     0.039  ]; n=n+1; % prestim_dur
  uipos(n,:) = [ 0.075    -0.04      0.04      0.031  ]; n=n+1; % poststim_dur label
  uipos(n,:) = [ 0.115    -0.04      0.045     0.039  ]; n=n+1; % poststim_dur
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  autoreject_cmd = [ ...
    'g = get(gcbf, ''userdata'');' ...
    'tmp_autoreject = g.autoreject;'...
    'g.autoreject  = get(findobj(gcbf, ''tag'', ''UI_autoreject''),''value'');'...
    'tmp_reject_lfp  = str2num(get(findobj(gcbf, ''tag'', ''UI_reject_lfp''),''string''));'...
    'tmp_reject_eeg  = str2num(get(findobj(gcbf, ''tag'', ''UI_reject_eeg''),''string''));'...
    'tmp_prestim_dur  = str2num(get(findobj(gcbf, ''tag'', ''UI_prestim_dur''),''string''));'...
    'tmp_poststim_dur  = str2num(get(findobj(gcbf, ''tag'', ''UI_poststim_dur''),''string''));'...
    'if size(tmp_reject_lfp)~=1 | tmp_reject_lfp<0'...
    '  set(findobj(gcbf, ''tag'', ''UI_reject_lfp''),''string'',num2str(g.reject_lfp));'...
    'else'...
    '  g.reject_lfp = tmp_reject_lfp;'...
    'end;'...
    'if size(tmp_reject_eeg)~=1 | tmp_reject_eeg<0'...
    '  set(findobj(gcbf, ''tag'', ''UI_reject_eeg''),''string'',num2str(g.reject_eeg));'...
    'else'...
    '  g.reject_eeg = tmp_reject_eeg;'...
    'end;'...
    'if size(tmp_prestim_dur)==1 & tmp_prestim_dur>=0'...
    '  g.prestim_dur = tmp_prestim_dur;'...
    '  g.prestim_samp = round(tmp_prestim_dur*g.srate/1000);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_prestim_dur''),''string'',num2str(g.prestim_dur));'...
    'if size(tmp_poststim_dur)==1 & tmp_poststim_dur>=0'...
    '  g.poststim_dur = tmp_poststim_dur;'...
    '  g.poststim_samp = round(tmp_poststim_dur*g.srate/1000);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_poststim_dur''),''string'',num2str(g.poststim_dur));'...
    'set(gcbf, ''userdata'', g);' ...
    'if tmp_autoreject | g.autoreject'...
    '  sig_browseraw(''findartifacts'');'...
    '  sig_browseraw(''updateevents'');'...
    '  sig_browseraw(''drawp'',0);'...
    'end;'...
    'clear tmp_autoreject tmp_reject_lfp tmp_reject_eeg;'...
    'clear tmp_poststimdur tmp_prestim_dur;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_autoreject',...
   'TooltipString','automatically mark rejected epochs',...
   'HorizontalAlignment', 'right',...
   'callback', autoreject_cmd,...
   'value', g.autoreject,...
   'string','AutoReject');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_reject_lfp',...
   'TooltipString','LFP rejection threshold (uV)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(g.reject_lfp));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_reject_eeg',...
   'TooltipString','EEG rejection threshold (uV)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(g.reject_eeg));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_reject_lfp_label',...
   'HorizontalAlignment', 'left',...
   'string','LFP');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_reject_eeg_label',...
   'HorizontalAlignment', 'left',...
   'string','EEG');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_prestim_dur_label',...
   'HorizontalAlignment', 'left',...
   'string','pre');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_prestim_dur',...
   'TooltipString','pre-stimulus duration (msec)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(g.prestim_dur));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_poststim_dur_label',...
   'HorizontalAlignment', 'left',...
   'string','post');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_poststim_dur',...
   'TooltipString','post-stimulus duration (msec)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(g.poststim_dur));
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % scale group
  ui_offset = ui_scale;

  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.16      0.05      0.031  ]; n=n+1; % scale label
  uipos(n,:) = [ 0.00      0.12      0.05      0.039  ]; n=n+1; % scale_lfp
  uipos(n,:) = [ 0.00      0.08      0.05      0.039  ]; n=n+1; % scale_eeg
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  scale_cmd = [ ...
    'g = get(gcbf, ''userdata'');' ...
    'tmp_scale_lfp  = str2num(get(findobj(gcbf, ''tag'', ''UI_scale_lfp''),''string''));'...
    'tmp_scale_eeg  = str2num(get(findobj(gcbf, ''tag'', ''UI_scale_eeg''),''string''));'...
    'if size(tmp_scale_lfp)~=1 | tmp_scale_lfp <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_scale_lfp''),''string'',num2str(g.scale_lfp));'...
    'else'...
    '  g.scale_lfp = tmp_scale_lfp;'...
    'end;'...
    'if size(tmp_scale_eeg)~=1 | tmp_scale_eeg <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_scale_eeg''),''string'',num2str(g.scale_eeg));'...
    'else'...
    '  g.scale_eeg = tmp_scale_eeg;'...
    'end;'...
    'set(gcbf, ''userdata'', g);' ...
    'sig_browseraw(''readfile'');'...
    'sig_browseraw(''updateevents'');'...
    'sig_browseraw(''drawp'',0);'...
    'clear tmp_scale_lfp tmp_scale_eeg;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_scale_label',...
   'HorizontalAlignment', 'left',...
   'string','Scale');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_scale_lfp',...
   'TooltipString','LFP display scale factor',...
   'HorizontalAlignment', 'left',...
   'callback', scale_cmd,...
   'string',num2str(g.scale_lfp));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_scale_eeg',...
   'TooltipString','EEG display scale factor',...
   'HorizontalAlignment', 'left',...
   'callback', scale_cmd,...
   'string',num2str(g.scale_eeg));
  n=n+1;
  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % filter group
  ui_offset = ui_filter;

  % set positions
  n=1;
  uipos(n,:) = [ 0.0       0.11      0.16      0.039  ]; n=n+1; % filter
  uipos(n,:) = [ 0.04      0.04      0.05      0.039  ]; n=n+1; % filter_low_cf
  uipos(n,:) = [ 0.11      0.04      0.05      0.039  ]; n=n+1; % filter_low_tb
  uipos(n,:) = [ 0.04      0.00      0.05      0.039  ]; n=n+1; % filter_high_cf
  uipos(n,:) = [ 0.11      0.00      0.05      0.039  ]; n=n+1; % filter_high_tb
  uipos(n,:) = [ 0.0       0.04      0.04      0.03   ]; n=n+1; % low label
  uipos(n,:) = [ 0.0       0.00      0.04      0.03   ]; n=n+1; % high label
  uipos(n,:) = [ 0.04      0.078     0.05      0.03   ]; n=n+1; % cutoff label
  uipos(n,:) = [ 0.10      0.078     0.07      0.03   ]; n=n+1; % trans label
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  filter_cmd = [ ...
    'g = get(gcbf, ''userdata'');' ...
    'tmp_filter = g.filter;'...
    'g.filter = get(findobj(gcbf, ''tag'', ''UI_filter''),''value'');'...
    'tmp_filter_low_cf = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_low_cf''),''string''));'...
    'tmp_filter_low_tb = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_low_tb''),''string''));'...
    'tmp_filter_high_cf = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_high_cf''),''string''));'...
    'tmp_filter_high_tb = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_high_tb''),''string''));'...
    'if size(tmp_filter_low_cf)~=1 | tmp_filter_low_cf <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_low_cf''),''string'',num2str(g.filter_low_cf));'...
    'else'...
    '  g.filter_low_cf = tmp_filter_low_cf;'...
    'end;'...
    'if size(tmp_filter_low_tb)~=1 | tmp_filter_low_tb <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_low_tb''),''string'',num2str(g.filter_low_tb));'...
    'else'...
    '  g.filter_low_tb = tmp_filter_low_tb;'...
    'end;'...
    'if size(tmp_filter_high_cf)~=1 | tmp_filter_high_cf <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_high_cf''),''string'',num2str(g.filter_high_cf));'...
    'else'...
    '  g.filter_high_cf = tmp_filter_high_cf;'...
    'end;'...
    'if size(tmp_filter_high_tb)~=1 | tmp_filter_high_tb <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_high_tb''),''string'',num2str(g.filter_high_tb));'...
    'else'...
    '  g.filter_high_tb = tmp_filter_high_tb;'...
    'end;'...
    'set(gcbf, ''userdata'', g);' ...
    'if tmp_filter'...
    '  sig_browseraw(''readfile'');'...
    'elseif g.filter'...
    '  sig_browseraw(''filterdata'');'...
    '  sig_browseraw(''findartifacts'');'...
    'end;'...
    'if tmp_filter || g.filter'...
    '  sig_browseraw(''updateevents'');'...
    '  sig_browseraw(''drawp'',0);'...
    'end;'...
    'clear tmp_filter tmp_filter_low_cf tmp_filter_low_tb tmp_filter_high_cf tmp_filter_high_tb;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_filter',...
   'TooltipString','apply bandpass fft filter',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'value', g.filter,...
   'string','Filter Data');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_low_cf',...
   'TooltipString','low cut off frequency (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(g.filter_low_cf));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_low_tb',...
   'TooltipString','low transition band (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(g.filter_low_tb));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_high_cf',...
   'TooltipString','high cut off frequency (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(g.filter_high_cf));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_high_tb',...
   'TooltipString','high transition band (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(g.filter_high_tb));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_low_label',...
   'HorizontalAlignment', 'left',...
   'string','low');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_high_label',...
   'HorizontalAlignment', 'left',...
   'string','high');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_cutoff_label',...
   'HorizontalAlignment', 'left',...
   'string','cut off');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_trans_label',...
   'HorizontalAlignment', 'left',...
   'string','transition');

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % value group
  ui_offset = ui_value;

  % set positions
  n=1;
  uipos(n,:) = [ 0.07      0.08      0.1       0.039  ]; n=n+1; % chanel
  uipos(n,:) = [ 0.0       0.08      0.07      0.039  ]; n=n+1; % channel label
  uipos(n,:) = [ 0.045     0.04      0.13      0.039  ]; n=n+1; % time
  uipos(n,:) = [ 0.0       0.04      0.045     0.039  ]; n=n+1; % time label
  uipos(n,:) = [ 0.055     0.0       0.13      0.039  ]; n=n+1; % value
  uipos(n,:) = [ 0.0       0.0       0.055     0.039  ]; n=n+1; % value label
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_chan',...
   'HorizontalAlignment', 'left',...
   'string',[]);
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_chan_label',...
   'HorizontalAlignment', 'left',...
   'string','Channel:');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_time',...
   'HorizontalAlignment', 'left',...
   'string',[]);
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_time_label',...
   'HorizontalAlignment', 'left',...
   'string','Time:');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_value',...
   'HorizontalAlignment', 'left',...
   'string',[]);
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_value_label',...
   'HorizontalAlignment', 'left',...
   'string','Value:');
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % spacing group
  ui_offset = ui_spacing;

  % set positions
  n=1;
  uipos(n,:) = [ 0.0       0.01      0.07      0.04   ]; n=n+1; % spacing
  uipos(n,:) = [ 0.08      0.03      0.03      0.0270 ]; n=n+1; % +
  uipos(n,:) = [ 0.08      0.0       0.03      0.0270 ]; n=n+1; % -
  uipos(n,:) = [ 0.01      0.055     0.10      0.031  ]; n=n+1; % spacing label
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_spacing',...
   'TooltipString','vertical spacing between channels in scaled units',...
   'string',num2str(g.spacing),...
   'Callback', 'sig_browseraw(''draws'',0);' );
  n=n+1;
  % UI_spacing buttons: + -
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','Pushbutton5',...
   'string','+',...
   'FontSize',8,...
   'Callback','sig_browseraw(''draws'',1)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','Pushbutton6',...
   'string','-',...
   'FontSize',8,...
   'Callback','sig_browseraw(''draws'',2)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_spacing_label',...
   'HorizontalAlignment', 'left',...
   'string','Spacing');

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % display group
  ui_offset = ui_display;

  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.20     0.12      0.031  ]; n=n+1; % winlength label
  uipos(n,:) = [ 0.12      0.20     0.04      0.039  ]; n=n+1; % winlength
  uipos(n,:) = [ 0.00      0.16     0.08      0.039  ]; n=n+1; % plot events
  uipos(n,:) = [ 0.08      0.16     0.08      0.039  ]; n=n+1; % display event durs
  uipos(n,:) = [ 0.00      0.12     0.08      0.039  ]; n=n+1; % xgrid
  uipos(n,:) = [ 0.08      0.12     0.08      0.039  ]; n=n+1; % ygrid
  uipos(n,:) = [ 0.00      0.08     0.16      0.039  ]; n=n+1; % showlabels
  uipos(n,:) = [ 0.00      0.04     0.16      0.039  ]; n=n+1; % submean
  uipos(n,:) = [ 0.00      0.00     0.12      0.033  ]; n=n+1; % dispchans label
  uipos(n,:) = [ 0.12      0.00     0.04      0.039  ]; n=n+1; % dispchans
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  winlength_cmd = [...
    'g = get(gcbf, ''userdata'');' ...
    'tmp_winlength = str2num(get(findobj(gcbf, ''tag'', ''UI_winlength''),''string''));'...
    'if size(tmp_winlength)==1 & tmp_winlength>0'...
    '  g.winlength = round(max(1,min(tmp_winlength,g.maxwinlength)));'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_winlength''),''string'',num2str(g.winlength));'...
    'set(gcbf, ''userdata'', g);' ...
    'sig_browseraw(''drawp'',5);'...
    'clear tmp_winlength;'...
  ];
  plotevent_cmd = [...
    'g = get(gcbf, ''userdata'');' ...
    'g.plotevent = get(findobj(gcbf, ''tag'', ''UI_plotevent''),''value'');'...
    'g.ploteventdur = get(findobj(gcbf, ''tag'', ''UI_ploteventdur''),''value'');'...
    'set(gcbf, ''userdata'', g);' ...
    'sig_browseraw(''updateevents'');'...
    'sig_browseraw(''drawb'');'...
  ];
  xgrid_cmd = [...
    'g = get(gcbf, ''userdata'');' ...
    'g.xgrid = get(findobj(gcbf, ''tag'', ''UI_xgrid''),''value'');'...
    'set(gcbf, ''userdata'', g);' ...
    'tmp_ax = findobj(''tag'',''UI_dataaxis'',''parent'',gcbf);',...
    'set(tmp_ax,''xgrid'',fastif(g.xgrid,''on'',''off''));',...
    'clear tmp_ax;'...
  ];
  ygrid_cmd = [...
    'g = get(gcbf, ''userdata'');' ...
    'g.ygrid = get(findobj(gcbf, ''tag'', ''UI_ygrid''),''value'');'...
    'set(gcbf, ''userdata'', g);' ...
    'tmp_ax = findobj(''tag'',''UI_dataaxis'',''parent'',gcbf);',...
    'set(tmp_ax,''ygrid'',fastif(g.ygrid,''on'',''off''));',...
    'clear tmp_ax;'...
  ];
  showlabels_cmd = [...
    'g = get(gcbf, ''userdata'');' ...
    'g.showlabels = get(findobj(gcbf, ''tag'', ''UI_showlabels''),''value'');'...
    'set(gcbf, ''userdata'', g);' ...
    'sig_browseraw(''setchanlabels'');'...
  ];
  submean_cmd = [...
    'g = get(gcbf, ''userdata'');' ...
    'g.submean = get(findobj(gcbf, ''tag'', ''UI_submean''),''value'');'...
    'set(gcbf, ''userdata'', g);' ...
    'sig_browseraw(''drawp'',0);'...
  ];
  dispchans_cmd = [ ...
    'g = get(gcbf, ''userdata'');' ...
    'tmp_dispchans = str2num(get(findobj(gcbf, ''tag'', ''UI_dispchans''),''string''));'...
    'if size(tmp_dispchans)==1 & tmp_dispchans>0'...
    '  g.dispchans = round(tmp_dispchans);'...
    '  g.actualdispchans = max(1,min(g.dispchans,length(g.readchans)));'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_dispchans''),''string'',num2str(g.dispchans));'...
    'set(gcbf, ''userdata'', g);' ...
    'sig_browseraw(''updateslider'', gcbf);'...
    'sig_browseraw(''drawp'',0);'...
    'clear tmp_dispchans;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_winlength_label',...
   'HorizontalAlignment', 'left',...
   'string','Window Length');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_winlength',...
   'TooltipString','duration of data to read/display (secs)',...
   'HorizontalAlignment', 'left',...
   'callback', winlength_cmd,...
   'string',num2str(g.winlength));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_plotevent',...
   'TooltipString','plot lines marking events',...
   'HorizontalAlignment', 'left',...
   'callback', plotevent_cmd,...
   'value', g.plotevent,...
   'string','events');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_ploteventdur',...
   'TooltipString','plot event durations',...
   'HorizontalAlignment', 'left',...
   'callback', plotevent_cmd,...
   'value', g.ploteventdur,...
   'string','durs');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_xgrid',...
   'TooltipString','display x grid lines',...
   'HorizontalAlignment', 'left',...
   'callback', xgrid_cmd,...
   'value', g.xgrid,...
   'string','x grid');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_ygrid',...
   'TooltipString','display y grid lines',...
   'HorizontalAlignment', 'left',...
   'callback', ygrid_cmd,...
   'value', g.ygrid,...
   'string','y grid');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_submean',...
   'TooltipString','subtract mean from each channel',...
   'HorizontalAlignment', 'left',...
   'callback', submean_cmd,...
   'value', g.submean,...
   'string','subtract mean');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_showlabels',...
   'TooltipString','show channel labels (instead of numbers)',...
   'HorizontalAlignment', 'left',...
   'callback', showlabels_cmd,...
   'value', g.showlabels,...
   'string','show chan labels');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_dispchans_label',...
   'HorizontalAlignment', 'left',...
   'string','disp # chans');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_dispchans',...
   'TooltipString','number of channels to display',...
   'HorizontalAlignment', 'left',...
   'callback', dispchans_cmd,...
   'string',num2str(g.dispchans));
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % manual group
  ui_offset = ui_manual;

  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.20     0.13      0.031  ]; n=n+1; % manual label
  uipos(n,:) = [ 0.00      0.16     0.08      0.039  ]; n=n+1; % manual_reject
  uipos(n,:) = [ 0.00      0.12     0.08      0.039  ]; n=n+1; % manual_event1
  uipos(n,:) = [ 0.08      0.12     0.04      0.039  ]; n=n+1; % manual_event_code1
  uipos(n,:) = [ 0.00      0.08     0.08      0.039  ]; n=n+1; % manual_event2
  uipos(n,:) = [ 0.08      0.08     0.04      0.039  ]; n=n+1; % manual_event_code2
  uipos(n,:) = [ 0.00      0.04     0.08      0.039  ]; n=n+1; % manual_event3
  uipos(n,:) = [ 0.08      0.04     0.04      0.039  ]; n=n+1; % manual_event_code3
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  manual_cmd = [...
    'g = get(gcbf, ''userdata'');' ...
    'tmp_manual_event_code1 = str2num(get(findobj(gcbf, ''tag'', ''UI_manual_event_code1''),''string''));'...
    'if size(tmp_manual_event_code1)~=1 | tmp_manual_event_code1 <0'...
    '  set(findobj(gcbf, ''tag'', ''tmp_manual_event_code1''),''string'',''1'');'...
    'end;'...
    'tmp_manual_event_code2 = str2num(get(findobj(gcbf, ''tag'', ''UI_manual_event_code2''),''string''));'...
    'if size(tmp_manual_event_code2)~=1 | tmp_manual_event_code2 <0'...
    '  set(findobj(gcbf, ''tag'', ''tmp_manual_event_code2''),''string'',''2'');'...
    'end;'...
    'tmp_manual_event_code3 = str2num(get(findobj(gcbf, ''tag'', ''UI_manual_event_code3''),''string''));'...
    'if size(tmp_manual_event_code3)~=1 | tmp_manual_event_code3 <0'...
    '  set(findobj(gcbf, ''tag'', ''tmp_manual_event_code3''),''string'',''3'');'...
    'end;'...
    'tmp_UI = get(gcbo,''tag'');' ...
    'if strcmp(tmp_UI,''UI_manual_reject'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',0);'...
    '  g.manual_reject = 1;'...
    '  g.manual_event  = 0;'...
    'elseif strcmp(tmp_UI,''UI_manual_event1'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',0);'...
    '  g.manual_reject = 0;'...
    '  g.manual_event  = 1;'...
    '  g.manual_event_code = tmp_manual_event_code1;'...
    'elseif strcmp(tmp_UI,''UI_manual_event2'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',0);'...
    '  g.manual_reject = 0;'...
    '  g.manual_event  = 1;'...
    '  g.manual_event_code = tmp_manual_event_code2;'...
    'elseif strcmp(tmp_UI,''UI_manual_event3'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',0);'...
    '  g.manual_reject = 0;'...
    '  g.manual_event  = 1;'...
    '  g.manual_event_code = tmp_manual_event_code3;'...
    'end;'...
    'g.tmpevent.latency = 0;'...
    'g.tmpevent.duration = 0;'...
    'set(gcbf, ''userdata'', g);' ...
    'clear tmp_UI tmp_manual_event_code1 tmp_manual_event_code2 tmp_manual_event_code3;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_manual_label',...
   'HorizontalAlignment', 'left',...
   'string','Manual Marking');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','radiobutton', ...
   'Tag','UI_manual_reject',...
   'TooltipString','mouse clicks on data window create manual rejects',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'value', 1,...
   'string','reject');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','radiobutton', ...
   'Tag','UI_manual_event1',...
   'TooltipString','mouse clicks on data window create manual events',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'value', 0,...
   'string','event');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_manual_event_code1',...
   'TooltipString','event code for manual event 1',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'string','1');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','radiobutton', ...
   'Tag','UI_manual_event2',...
   'TooltipString','mouse clicks on data window create manual events',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'value', 0,...
   'string','event');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_manual_event_code2',...
   'TooltipString','event code for manual event 2',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'string','2');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','radiobutton', ...
   'Tag','UI_manual_event3',...
   'TooltipString','mouse clicks on data window create manual events',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'value', 0,...
   'string','event');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_manual_event_code3',...
   'TooltipString','event code for manual event 3',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'string','3');
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  set(figh, 'windowbuttondownfcn', 'sig_browseraw(''mouseclickdown'')');
  set(figh, 'windowbuttonmotionfcn', 'sig_browseraw(''mousemove'')');
  set(figh, 'interruptible', 'off');
  set(figh, 'busyaction', 'cancel');

  g.commandselect = { 'sig_browseraw(''mouseclickdown'')' 'sig_browseraw(''mousemove'')' '' };

  % make sure events have proper fields
  if ~isempty(g.events)
    if ~isfield(g.events, 'type') | ~isfield(g.events, 'latency'), g.events = []; end;
    if ~isfield(g.events, 'duration') | ~isfield(g.events, 'condition'), g.events = []; end;
  end;

  % make sure event durations are numeric
  for ev=1:length(g.events)
    if ~isnumeric(g.events(ev).duration) | size(g.events(ev).duration)~=1
      g.events(ev).duration = 1;
    end;
    if g.events(ev).duration==0
      g.events(ev).duration = 1;
    end;
    if isempty(g.events(ev).condition)
      g.events(ev).condition = 0;
    end;
  end;
  
  %% todo: add support for numeric or string codes?
  % make sure event conditions are numeric
  for ev=1:length(g.events)
    if ~isnumeric(g.events(ev).condition) | size(g.events(ev).condition)~=1
      g.events(ev).condition = 0;
    end;
  end;
 
  set(figh, 'UserData', g);
  sig_browseraw('readfile');
  sig_browseraw('initevents');
  sig_browseraw('updateevents');
  g = get(figh,'UserData');

  hold(ax1,'on');

  % reset spacing and draw data
  UI_spacing = findobj('tag','UI_spacing','parent',figh);   % ui handle
  set(UI_spacing,'string',num2str(g.spacing,4))  % update edit box
  sig_browseraw('draws',0);
  if g.actualdispchans ~= g.chans
    sig_browseraw('zoom', gcf);
  end;

  h = findobj(gcf, 'style', 'pushbutton');
  set(h, 'backgroundcolor', BUTTON_COLOR);
  h = findobj(gcf, 'tag', 'UI_slider');
  set(h, 'backgroundcolor', BUTTON_COLOR);
  set(figh, 'visible', 'on');
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% end main function
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
else
  try p1 = varargin{1}; p2 = varargin{2}; p3 = varargin{3}; catch, end;
  switch datamatrix
  case 'drawp' % Redraw data and change position
    % this test help to couple sig_browseraw windows
    if exist('p3')
        figh = p3;
        figure(p3);
    else    
        figh = gcf;                          % figure handle
    end;
    
    if strcmp(get(figh,'tag'),'dialog')
      figh = get(figh,'UserData');
    end
    ax0 = findobj('tag','UI_backaxis','parent',figh); % axes handle
    ax1 = findobj('tag','UI_dataaxis','parent',figh); % axes handle
    g = get(figh,'UserData');
    data = get(ax1,'UserData');
    UI_spacing = findobj('tag','UI_spacing','parent',figh);   % ui handle
    UI_position = findobj('tag','UI_position','parent',figh); % ui handle
    tmp_spacing = str2num(get(UI_spacing,'string'));
    if size(tmp_spacing)==1 & tmp_spacing>0
      g.spacing = tmp_spacing;
    end;
    set(findobj('tag','UI_spacing','parent',figh), 'string', num2str(g.spacing));

    newtime = str2num(get(UI_position,'string'));
    if(newtime ~= g.rawbegtime)
      if(newtime < 0)
        g.rawbegtime = 0;
      else
        g.rawbegtime = newtime;
      end
      g.rawendtime = g.rawbegtime + g.winlength;
      newtime = 1;
    else
      newtime = 0;
    end
    if p1 == 1
      g.rawbegtime = g.rawbegtime - g.winlength;
      g.rawendtime = g.rawbegtime + g.winlength;
      newtime = 1;
    elseif p1 == 2               
      % < subtract one second or 1/5 of winlength
      g.rawbegtime=g.rawbegtime-fastif(g.winlength>=1, 1, g.winlength/5);
      g.rawendtime=g.rawbegtime+g.winlength;
      newtime = 1;
    elseif p1 == 3
      % > add one second or 1/5 of winlength
      g.rawbegtime=g.rawbegtime+fastif(g.winlength>=1, 1, g.winlength/5);
      g.rawendtime=g.rawbegtime+g.winlength;
      newtime = 1;
    elseif p1 == 4
      g.rawbegtime = g.rawbegtime + g.winlength;
      g.rawendtime = g.rawbegtime + g.winlength;
      newtime = 1;
    elseif p1 == 5
      g.rawbegtime = g.rawbegtime;
      g.rawendtime = g.rawbegtime + g.winlength;
      newtime = 1;
    end
    
    %% make sure we don't reverse to negative
    if(g.rawbegtime<0)
      g.rawbegtime = 0;
      g.rawendtime = g.rawbegtime + g.winlength;
      newtime = 1;
    end
    
    % make sure we don't advance past tlast (if tlast is known)
    if(g.hdr.tlast>0)
      if(g.rawbegtime>g.hdr.tlast)
        g.rawbegtime = g.hdr.tlast;
        g.rawendtime = g.rawbegtime + g.winlength;
        newtime = 1;
      end
    end
    
    if(newtime)
      set(figh, 'UserData', g);
      sig_browseraw('clearrejects');
      sig_browseraw('readfile');
      sig_browseraw('updateevents');
      g = get(figh,'UserData');
      data = get(ax1,'UserData');
      [g.chans,g.frames] = size(data);
    end

    multiplier = g.srate;
    
    % Update edit box
    % ---------------
    set(UI_position,'string',num2str(g.rawbegtime)); 
    set(figh, 'userdata', g);

    % calculate mean for each channel
    if(g.submean)
      meandata = nanmean(data');
    else
      meandata = zeros(1,g.chans);
    end;

    if g.spacing == 0
      maxindex = min(10000, g.frames);  
      g.spacing = 0.1*max(max(data(:,1:maxindex),[],2),[],1)-min(min(data(:,1:maxindex),[],2),[],1);  % Set g.spacingto max/min data
    end;
    if g.spacing == 0
      g.spacing = 100;
    end;

    % plot data (but don't actually draw yet)
    % ---------
    cla(ax1);
    hold(ax1,'on');
    for i = 1:g.chans
      plot(ax1,data(g.chans-i+1,:)-meandata(g.chans-i+1)+i*g.spacing, ...
        'color', g.color{mod(i-1,length(g.color))+1}, 'clipping','on')
    end
    set(ax1, 'Xlim',[1 g.winlength*multiplier+1],...
             'XTick',[1:multiplier*DEFAULT_GRID_SPACING:g.winlength*multiplier+1]);
    set(ax1, 'XTickLabel', num2str((g.rawbegtime:DEFAULT_GRID_SPACING:g.rawbegtime+g.winlength)'))
    set(ax1, 'ylim',[g.chanoffset*g.spacing (g.chanoffset+g.actualdispchans+1)*g.spacing] );
    sig_browseraw('drawb'); % will actually draw data

    if g.children ~= 0
      if ~exist('p2')
        p2 =[];
      end;    
      sig_browseraw( 'drawp', p1, p2, g.children);
      figure(figh);
    end;
     
  case 'drawb' % Draw background ******************************************************
    % Redraw data and change position
    ax0 = findobj('tag','UI_backaxis','parent',gcf); % axes handle
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
    g = get(gcf,'UserData');  % Data (Note: this could also be global)

    % draw background axis now and set as current axis for drawing events
    axes(ax0);
    cla;
    hold on;

    multiplier = g.srate;

    % draw events if any
    % ------------------
    tmp_event_ticks = [];
    tmp_event_labels = [];
    if g.plotevent
      lowlim = round(g.rawbegtime*multiplier+1);
      highlim = round(g.rawendtime*multiplier+1);

      % find events to plot
      % ------------------
      g.eventlatencies  = cell2mat({g.events.latency g.tmpevent.latency})+1;
      g.eventlatencyend = g.eventlatencies + cell2mat({g.events.duration g.tmpevent.duration})+1;
      g.eventconditions = cell2mat({g.events.condition g.tmpevent.condition});
      event2plot = find ( g.eventlatencies >=lowlim & g.eventlatencies <= highlim );
      if ~isempty(g.eventlatencyend)            
          event2plot2 = find ( g.eventlatencyend >= lowlim & g.eventlatencyend <= highlim );
          event2plot3 = find ( g.eventlatencies  <  lowlim & g.eventlatencyend >  highlim );
          event2plot  = union(union(event2plot, event2plot2), event2plot3);
      end;

      for index = 1:length(event2plot)
        % draw latency line
        % -----------------
        tmplat = g.eventlatencies(event2plot(index))-lowlim-1;
        tmpcond = g.eventconditions(event2plot(index));
        tmph   = plot([ tmplat tmplat ], ylim, 'color', g.eventcolors{ event2plot(index) }, ...
                      'linestyle', g.eventstyle { event2plot(index) }, ...
                      'linewidth', g.eventwidths( event2plot(index) ) );

        if tmplat>0 & tmpcond>0
          % display event code numbers (condition) at top of plot for each event
          tmp_event_ticks(end+1) = tmplat;
          tmp_event_labels(end+1) = tmpcond;
        end;

        % draw duration is not 0
        % ----------------------
        if g.ploteventdur & ~isempty(g.eventlatencyend)
          tmplatend = g.eventlatencyend(event2plot(index))-lowlim-1;
          if tmplatend ~= 0, 
            tmplim = ylim;
            tmpcol = g.eventcolors{ event2plot(index) };
            h = patch([ tmplat tmplatend tmplatend tmplat ], ...
                      [ tmplim(1) tmplim(1) tmplim(2) tmplim(2) ], ...
                      tmpcol );  % this argument is color
            set(h, 'EdgeColor', 'none') 
          end;
        end;
      end;
    end;

    % sort event tick labels
    if ~isempty(tmp_event_ticks)
      [tmp_event_ticks, indx] = sort(tmp_event_ticks);
      tmp_event_labels = tmp_event_labels(indx);
    end

    set(ax0,'XTickLabel', tmp_event_labels,'YTickLabel', [],...
      'Xlim',[0 g.winlength*multiplier],...
      'XTick',tmp_event_ticks, 'YTick',[], 'tag','UI_backaxis');
    set(ax1,'XTickLabel', num2str((g.rawbegtime:DEFAULT_GRID_SPACING:g.rawbegtime+g.winlength)'),...
    'XTick',[1:multiplier*DEFAULT_GRID_SPACING:g.winlength*multiplier+1])
    set(ax1, 'ylim',[g.chanoffset*g.spacing (g.chanoffset+g.actualdispchans+1)*g.spacing] );

    axes(ax1); % actually draw data now
    return;

  case 'draws'
    % Redraw EEG and change scale
    ax1 = findobj('tag','UI_dataaxis','parent',gcf);         % axes handle
    g = get(gcf,'UserData');  
    data = get(ax1, 'userdata');
    UI_spacing = findobj('tag','UI_spacing','parent',gcf);   % ui handle
    UI_position = findobj('tag','UI_position','parent',gcf); % ui handle
    tmp_spacing = str2num(get(UI_spacing,'string'));
    if size(tmp_spacing)==1 & tmp_spacing>=0
      g.spacing = tmp_spacing;
    end;
    set(findobj('tag','UI_spacing','parent',gcf), 'string', num2str(g.spacing));
    orgspacing= g.spacing;
    if p1 == 1
      g.spacing= g.spacing+ 0.1*orgspacing; % increase g.spacing(5%)
    elseif p1 == 2
      g.spacing= max(0,g.spacing-0.1*orgspacing); % decrease g.spacing(5%)
    end
    if g.spacing == 0
      maxindex = min(10000, g.frames);  
      g.spacing = 0.1*max(max(data(:,1:maxindex),[],2),[],1)-min(min(data(:,1:maxindex),[],2),[],1);  % Set g.spacingto max/min data
    end;
    g.spacing = full(g.spacing); % weirdly sparse when only one channel
    set(UI_spacing,'string',num2str(g.spacing,4))  % update edit box
    set(gcf, 'userdata', g);
    sig_browseraw('drawp', 0);
    set(ax1,'YLim',[0 (g.chans+1)*g.spacing],'YTick',[0:g.spacing:g.chans*g.spacing])
    set(ax1, 'ylim',[g.chanoffset*g.spacing (g.chanoffset+g.actualdispchans+1)*g.spacing] );
    return;

  case 'initevents'  % initialize events for plotting
    g = get(gcf,'UserData');

    % create dummy events for autoreject, manual reject, and manual events
    %   so that they will be assigned colors that don't change
    g.events(end+1).type = 'autoreject';
    g.events(end  ).latency = 0;
    g.events(end  ).condition = 0;
    g.events(end  ).duration = 0;

    g.events(end+1).type = 'reject';
    g.events(end  ).latency = 0;
    g.events(end  ).condition = 0;
    g.events(end  ).duration = 0;

    g.events(end+1).type = 'manual';
    g.events(end  ).latency = 0;
    g.events(end  ).condition = 0;
    g.events(end  ).duration = 0;

    g.tmpevent = g.events(end); % tmp event will be used for marking events

    set(gcf, 'userdata', g);
    return;

  case 'updateevents'  % initialize events for plotting
    g = get(gcf,'UserData');

    if ~isempty(g.events)
      if isstr(g.events(1).type)
        [g.eventtypes tmpind indexcolor] = unique({g.events.type g.tmpevent.type}); % indexcolor counting as the event type
      else
        [g.eventtypes tmpind indexcolor] = unique(cell2mat({g.events.type}));
      end;
      g.eventcolors     = { 'r', 'c', 'm', 'b', [0 0.8 0], 'g', [0 0.8 0] };  
      g.eventstyle      = { '-' '-' '-'  '-'  '-' '-' '-' '--' '--' '--'  '--' '--' '--' '--'};
      g.eventwidths     = [ 2 1 ];
      g.eventtypecolors = g.eventcolors(mod([1:length(g.eventtypes)]-1 ,length(g.eventcolors))+1);
      g.eventcolors     = g.eventcolors(mod(indexcolor-1               ,length(g.eventcolors))+1);
      g.eventtypestyle  = g.eventstyle (mod([1:length(g.eventtypes)]-1 ,length(g.eventstyle))+1);
      g.eventstyle      = g.eventstyle (mod(indexcolor-1               ,length(g.eventstyle))+1);
      % this seems kind of pointless:
      indexwidth = ones(1,length(g.eventtypes))*2;
      g.eventtypewidths = g.eventwidths (mod(indexwidth([1:length(g.eventtypes)])-1 ,length(g.eventwidths))+1);
      g.eventwidths     = g.eventwidths (mod(indexwidth(indexcolor)-1               ,length(g.eventwidths))+1);
    end;
    if isempty(g.events)
      g.plotevent = 0;
    end;
    set(gcf, 'UserData', g);
    return;
    
  case 'setchanlabels'
    g = get(gcf,'UserData');
    AXH0 = findobj('tag','UI_dataaxis','parent',gcf);
    AXH1 = findobj('tag','UI_backaxis','parent',gcf);
    if g.showlabels
      YLabels = g.hdr.sensors.label(g.readchans);
      YLabels = strvcat(YLabels);
      YLabels = flipud(str2mat(YLabels,' '));
      set(AXH0,'YTickLabel',YLabels,'Position',LABELS_AXES_POSITION);
      set(AXH1,'Position',LABELS_AXES_POSITION);
    else
      YLabels = num2str(g.readchans'); % use chan numbers by default
      YLabels = flipud(str2mat(YLabels,' '));
      set(AXH0,'YTickLabel',YLabels,'Position',DEFAULT_AXES_POSITION);
      set(AXH1,'Position',DEFAULT_AXES_POSITION);
    end;    
    return;

  case 'zoom' % if zoom
    fig = varargin{1};
    ax1 = findobj('tag','UI_dataaxis','parent',fig); 
    ax2 = findobj('tag','UI_backaxis','parent',fig); 
    tmpxlim  = get(ax1, 'xlim');
    tmpylim  = get(ax1, 'ylim');
    tmpxlim2 = get(ax2, 'xlim');
    set(ax2, 'xlim', get(ax1, 'xlim'));
    g = get(fig,'UserData');

    % deal with abscicia
    % ------------------
    Eposition = str2num(get(findobj('tag','UI_position','parent',fig), 'string'))-1;
    g.winlength = (tmpxlim(2) - tmpxlim(1))/g.srate;    
    Eposition = Eposition + (tmpxlim(1) - tmpxlim2(1)-1)/g.srate;
    Eposition = round(Eposition*1000)/1000;
    set(findobj('tag','UI_position','parent',fig), 'string', num2str(Eposition+1));

    % deal with ordinate
    % ------------------
    g.chanoffset = tmpylim(1)/g.spacing;
    g.actualdispchans  = round(1000*(tmpylim(2)-tmpylim(1))/g.spacing)/1000;      

    set(fig,'UserData', g);
    sig_browseraw('updateslider', fig);
    sig_browseraw('drawp', 0);

    % reactivate zoom if 3 arguments
    % ------------------------------
    if exist('p2') == 1
      zoom on;
      tmpstr = get(gcbf, 'windowbuttondownfcn');
      set(gcbf, 'windowbuttondownfcn', [ tmpstr '; sig_browseraw(''zoom'', gcbf, 1);' ]);
      set(gcbf, 'windowbuttonmotionfcn', g.commandselect{2});
    end;

  case 'updateslider' % if zoom
    fig = varargin{1};
    g = get(fig,'UserData');
    slider = findobj('tag','UI_slider','parent',fig);
    if g.chanoffset < 0
      g.chanoffset = 0;
    end;
    if g.dispchans > g.chans
      g.actualdispchans = g.chans;
    else
      g.actualdispchans = g.dispchans;
    end;
    if g.actualdispchans >= g.chans
      g.actualdispchans = g.chans;
      g.chanoffset = 0;
      set(slider, 'visible', 'off');
    else
      set(slider, 'visible', 'on');         
      set(slider, 'value', g.chanoffset/g.chans, ...
                   'sliderstep', [1/(g.chans-g.actualdispchans) g.actualdispchans/(g.chans-g.actualdispchans)]);
    end;
    if g.chanoffset < 0
      g.chanoffset = 0;
    end;
    if g.chanoffset > g.chans-g.actualdispchans
      g.chanoffset = g.chans-g.actualdispchans;
    end;
    set(fig,'UserData', g);
   
  case 'drawlegend'
    fig = varargin{1};
    g = get(fig,'UserData');

    if ~isempty(g.events)
        nleg = length(g.eventtypes);
        fig2 = figure('numbertitle', 'off', 'name', '', 'visible', 'off', 'menubar', 'none', 'color', DEFAULT_FIG_COLOR);
        pos = get(fig2, 'position');
        set(fig2, 'position', [ pos(1) pos(2) 130 10*nleg+20]);

        for index = 1:nleg
            plot([10 30], [(index-0.5) * 10 (index-0.5) * 10], 'color', g.eventtypecolors{index}, 'linestyle', ...
                        g.eventtypestyle{ index }, 'linewidth', g.eventtypewidths( index )); hold on;
            if iscell(g.eventtypes)
                text(35, (index-0.5)*10, g.eventtypes{index});
            else
                text(35, (index-0.5)*10, num2str(g.eventtypes(index)));
            end;
        end;
        xlim([0 130]);
        ylim([0 nleg*10]);
        axis off;
        set(fig2, 'visible', 'on');
    end;

  case 'clearmanual'
    g = get(gcf,'UserData');
    lowlim = g.rawbegtime*g.srate+1;
    highlim = g.rawendtime*g.srate+1;
    if ~isempty(g.events)
      manual = [find(strcmp('manual',{g.events.type}))...;
                find(strcmp('reject',{g.events.type}))];
      for i=1:length(manual)
        index = manual(i);
        t_start = g.events(index).latency;
        t_end = t_start + g.events(index).duration;
        if (((t_start > lowlim) && (t_start < highlim)) || ...
            ((t_end > lowlim) && (t_end < highlim)))
          g.events(index).duration = 0;
        end;
      end;
      keep = find(cell2mat({g.events.duration})~=0);
      g.events = g.events(keep);
    end;
    set(gcf,'UserData', g);
    sig_browseraw('initevents');
    return;

  case 'clearrejects'
    g = get(gcf,'UserData');
    if ~isempty(g.events)
      % clear all autorejects
      autorejects = find(strcmp('autoreject',{g.events.type}));
      if ~isempty(autorejects)
        others = setdiff(1:length(g.events),autorejects);
        g.events = g.events(others);
      end;
    end;
    set(gcf,'UserData', g);
    sig_browseraw('initevents');
    return;

 %% todo: do something about duplicate or overlapping events (e.g. rejects)?
 %        or different but simultaneous events?
  case 'sortevents'
    g = get(gcbf,'UserData');
    if ~isempty(g.events)
      [foo, indx] = sort([g.events.latency]);
      g.events = g.events(indx);
    end
    set(gcbf,'UserData', g);
    return;

  case 'findartifacts'
    g = get(gcf,'UserData');
    if ~g.autoreject || ~g.plotevent, return; end;
    sig_browseraw('clearrejects');
    g = get(gcf,'UserData');
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle

    % which channels are which type
    g.lfp_i = find(strcmp('lfp',{g.hdr.sensors.typestring{:}})); %
    g.eeg_i = find(strcmp('eeg',{g.hdr.sensors.typestring{:}})); %

    reject_thresh(g.lfp_i)  = g.reject_lfp*g.scale_lfp;
    reject_thresh(g.eeg_i)  = g.reject_eeg*g.scale_eeg;
    reject_thresh(find(reject_thresh<=0)) = inf;
    reject_thresh = reject_thresh(g.readchans)';

    data = get(ax1,'UserData');
    [g.chans,g.frames]=size(data);

    % calculate mean for each channel
    if(g.submean)
      meandata = nan_mean(data');
    else
      meandata = zeros(1,g.chans);
    end;

    time_mask = zeros(1,g.frames);
    [reject_chans,reject_samples] = ...
      find(abs(data-meandata'*ones(size(time_mask)))>...
        reject_thresh*ones(size(time_mask)));
    %% todo: do something to let user know which channel caused rejection

    % expand rejected epochs with prestim_samp and poststim_samp
    time_mask(reject_samples) = 1;
    numsamples = length(time_mask);
    ind_nonzero =find(time_mask~=0);
    ind_onset   =find(abs(diff([-1 ind_nonzero]))>1);
    ind_offset  =find(abs(diff([ind_nonzero -1]))>1);
    last_offset=0;
    for i=1:length(ind_onset)
      onset = ind_nonzero(ind_onset(i));
      offset = ind_nonzero(ind_offset(i));
      onset = onset - g.poststim_samp;
      offset = offset + g.prestim_samp;
      if offset < last_offset, continue; end;
      if onset < 1, onset = 1; end;
      if offset > numsamples, offset = numsamples; end;
      time_mask(onset:offset)=1;
      if offset >= numsamples, break; end;
      last_offset = offset;
    end;

    % create autoreject events from reject_samples
    begsample = round(g.rawbegtime*g.srate + 1);
    ind_nonzero =find(time_mask~=0);
    ind_onset   =find(abs(diff([-1 ind_nonzero]))>1);
    ind_offset  =find(abs(diff([ind_nonzero -1]))>1);
    for i=1:length(ind_onset)
      onset = ind_nonzero(ind_onset(i));
      offset = ind_nonzero(ind_offset(i));
      g.events(end+1).type = 'autoreject';
      g.events(end  ).latency = begsample + onset;
      g.events(end  ).condition = 0;
      g.events(end  ).duration = offset - onset + 1;
    end;

    set(gcf,'UserData', g);
    return;

  case 'scaledata'
    g = get(gcf,'UserData');
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
    data = get(ax1,'UserData');

    % generate scale factors for each channel
    scale_facts = ones(g.hdr.nChans,1);
    scale_facts(g.lfp_i) = PRESCALE_LFP*g.scale_lfp;
    scale_facts(g.eeg_i) = PRESCALE_EEG*g.scale_eeg;

    data = diag(sparse(scale_facts(g.readchans)))*data;

    set(gcf, 'UserData', g);
    set(ax1, 'UserData', data);
    return;

  case 'filterdata'
    g = get(gcf,'UserData');
    if ~g.filter, return; end;
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
    data = get(ax1,'UserData');

    if g.filter_low_cf > g.filter_high_cf
      temp = g.filter_high_cf;
      g.filter_high_cf = g.filter_low_cf;
      g.filter_low_cf  = g.filter_high_cf;
      temp = g.filter_high_tb;
      g.filter_high_tb = g.filter_low_tb;
      g.filter_low_tb  = g.filter_high_tb;
    end
    if g.filter_high_tb < 0, g.filter_high_tb=0; end;
    if g.filter_low_tb < 0, g.filter_low_tb=0; end;
    data = freq_filt(data',g.srate,[g.filter_low_cf,g.filter_high_cf],...
      [g.filter_low_tb,g.filter_high_tb],'bandpass')';
    if isempty(data)
      fprintf('%s: error filtering data\n',mfilename);
      return;
    end;
    set(gcf, 'UserData', g);
    set(ax1, 'UserData', data);
    return;

  case 'setreadchans'
    g = get(gcf,'UserData');

    if g.minchan < 1, g.minchan = 1; end;
    if g.maxchan < 1 || g.maxchan > g.hdr.nChans, g.maxchan = g.hdr.nChans; end;
    if g.minchan > g.maxchan, g.minchan = g.maxchan; end;
    g.readchans = [g.minchan:g.maxchan];
    g.readchans = find(~ismember(g.readchans,g.badchans));

    % which channels are which type
    g.lfp_i = find(strcmp('lfp',{g.hdr.sensors.typestring{:}})); %
    g.eeg_i = find(strcmp('eeg',{g.hdr.sensors.typestring{:}})); %

    % exclude certain channel types from g.rawchans
    if ~g.read_lfp
      g.lfp_i = [];
    end;    
    if ~g.read_eeg
      g.eeg_i = [];
    end;

    g.readchans = intersect(g.readchans,...
      [g.lfp_i g.eeg_i]);
    g.chans = length(g.readchans);
    if g.dispchans==0, g.dispchans = g.chans; end;
    g.actualdispchans = min(g.dispchans,g.chans);

    set(gcf, 'UserData', g);
    return;

  case 'mouseclickdown'
    seltype = get(gcbf,'SelectionType');
    ax1 = findobj('tag','UI_backaxis','parent',gcbf);
    tmppos = get(ax1, 'currentpoint');
    g = get(gcbf,'UserData');
    cursamp = round(tmppos(1) + g.rawbegtime*g.srate + 1);
    if (strcmp(seltype,'normal')) % left mouse click
      if cursamp > g.rawbegtime*g.srate && cursamp < g.rawendtime*g.srate
        if g.manual_reject
          g.tmpevent.type = 'reject';
          g.tmpevent.latency = cursamp-1;
          g.tmpevent.condition = 0;
          g.tmpevent.duration = 1;
        elseif g.manual_event
          g.tmpevent.type = 'manual';
          g.tmpevent.latency = cursamp-1;
          g.tmpevent.condition = g.manual_event_code;
          g.tmpevent.duration = 1;
        end;
      else % if out of window range, no event
        g.tmpevent.latency = 0;
        g.tmpevent.duration = 0;
      end;
      set(gcbf,'UserData', g);
      sig_browseraw('updateevents');
      sig_browseraw('drawb'); % redraw event lines
    elseif (strcmp(seltype,'alt'))  % right mouse click
      if g.tmpevent.latency ~= 0
        if (cursamp < g.rawbegtime*g.srate)
          cursamp = g.rawbegtime*g.srate + 1;
        elseif (cursamp > g.rawendtime*g.srate)
          cursamp = g.rawendtime*g.srate;
        end;
        g.tmpevent.duration = max(1,abs(cursamp-1-g.tmpevent.latency));
        if (g.tmpevent.latency > cursamp-1)
          g.tmpevent.latency = cursamp-1;
        end;
        g.events(end+1) = g.tmpevent;
        g.tmpevent.latency = 0;
        g.tmpevent.duration = 0;
        set(gcbf,'UserData', g);
        sig_browseraw('updateevents');
        sig_browseraw('drawb'); % redraw event lines
      end;
    end;
    return;

  case 'mousemove'
  % mousemove: display time, channel, value for cursor position
    ax1 = findobj('tag','UI_backaxis','parent',gcbf);
    tmppos = get(ax1, 'currentpoint');
    g = get(gcbf,'UserData');
    if isstruct(g)      %check if we are dealing with the right window
      hh = findobj('tag','UI_time','parent',gcbf);
      tmptime = g.rawbegtime + (tmppos(1))/g.srate;
      if tmptime < g.rawbegtime || tmptime > g.rawendtime
        set(hh, 'string', []);
        hh = findobj('tag','UI_chan','parent',gcbf);
        set(hh, 'string', []);
        hh = findobj('tag','UI_value','parent',gcbf);
        set(hh, 'string', []);
      else
        tmpstring = sprintf('%0.4f sec',tmptime);
        set(hh, 'string', tmpstring); % put time in the box
        ax1 = findobj('tag','UI_dataaxis','parent',gcbf); 
        tmppos = get(ax1, 'currentpoint');
        tmpchan = round(tmppos(1,2) / g.spacing);
        tmpchan = min(max(double(tmpchan), 1),g.chans);
        tmpchan_i = g.chans+1-tmpchan;
        tmpchan_j = g.readchans(tmpchan_i);
        tmptype = g.hdr.sensors.typestring{tmpchan_j};
        if strcmp(tmptype,'lfp')
          tmpscale = g.scale_lfp;
          tmpunits = 'uV';
        end;
        if strcmp(tmptype,'eeg')
          tmpscale = g.scale_eeg;
          tmpunits = 'uV';
        end;
        labls = get(ax1, 'YtickLabel');
        hh = findobj('tag','UI_chan','parent',gcbf);  % put channel in the box
        set(hh, 'string', labls(tmpchan+1,:));
        hh = findobj('tag','UI_value','parent',gcbf);
        eegplotdata = get(ax1, 'userdata');
        if ~isempty(eegplotdata)
          tmpval = eegplotdata(tmpchan_i, min(g.frames,max(1,double(round(tmppos(1)+1)))))/tmpscale;
          if g.submean
            tmpmean = mean(eegplotdata(tmpchan_i,:)/tmpscale);
            tmpval = tmpval - tmpmean;
          end;
          tmpstring = sprintf('%0.2f %s',tmpval,tmpunits);
          set(hh, 'string', tmpstring);  % put value in the box
        end;
      end;
    end;
    return;

  case 'readfile'
    g = get(gcf,'UserData');
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
%    fprintf('reading raw data from %s...\n',g.datafile);
    begsample = round(g.rawbegtime*g.srate + 1);
    endsample = round(g.rawendtime*g.srate);

    if isempty(g.readchans)
      set(ax1, 'UserData', zeros(g.chans,g.frames));
      return;
    end;

    data = g.datamatrix(g.readchans, begsample:endsample);

    set(gcf, 'UserData', g);
    set(ax1, 'UserData', data);

    % scale each channel
    sig_browseraw('scaledata');

    % apply bandpass filter
    sig_browseraw('filterdata');
 
    % find artifacts
    sig_browseraw('findartifacts');

    return;

  otherwise
    error(['Error - invalid sig_browseraw() parameter: ',data])
  end  

end

%=======
function F_filt= freq_filt(F,fs,f0,df,filt_type)

F_filt = [];

if nargin<5
  help(mfilename);
  return;
end;

m=size(F,1);
if m==1 % one row vector
    F=F';
end
[m,n]=size(F);

Nfft=2^(ceil(log2(m))); % number of FFT terms

%F_attach=[zeros(size(F));F;zeros(size(F))]; % flip the signal and attach to bath ends
%id_orig=(m+1):2*m;

freq=linspace(0,1,Nfft)*fs;


switch lower(filt_type)
    case 'lowpass'
        Wp=f0-df/2.0; % pass point
        Ws=f0+df/2.0; % stop point
        ind=[ceil(Wp*Nfft/fs) ceil(Ws*Nfft/fs)]; % get the index number
        mask=zeros(Nfft/2,1); % the mask function in freq domain
        mask(1:ind(1))=1; % low freq side pass
        w=hanning(2*(ind(2)-ind(1))+1); % hanning window for transition
        mask((ind(1)+1):ind(2))=flipud(w(1:length((ind(1)+1):ind(2)))); % replace a portion of mask with hanning window
    case 'highpass'
        Wp=f0+df/2.0;
        Ws=f0-df/2.0;
        ind=[ceil(Ws*Nfft/fs) ceil(Wp*Nfft/fs)];
        mask=zeros(Nfft/2,1); % the mask function in freq domain
        mask((ind(2)+1):length(mask))=1;
        w=hanning(2*(ind(2)-ind(1))+1);
        mask((ind(1)+1):ind(2))=w(1:length((ind(1)+1):ind(2)));
    case 'notch'
        Wp1=f0-df; % low freq side, pass point, not divided by 2
        Wp2=f0+df; % high freq side, pass point
        ind=[ceil(Wp1*Nfft/fs) ceil(Wp2*Nfft/fs)];
        mask=zeros(Nfft/2,1); % the mask function in freq domain
        mask=mask+1;
        w=hanning(ind(2)-ind(1)+1);
        mask(ind(1):ind(2))=mask(ind(1):ind(2))-w;    
    case 'pointpass'
        Ws1=f0-df; % low freq side, stop point
        Ws2=f0+df; % high freq side, stop point
        ind=[ceil(Ws1*Nfft/fs) ceil(Ws2*Nfft/fs)];
        w=hanning(ind(2)-ind(1)+1);
        mask=zeros(Nfft/2,1); % the mask function in freq domain
        mask(ind(1):ind(2))=w;
    case 'bandpass'
        if length(f0) ~=2 | length(df)~=2,
            error('For bandpass filter, f0 and df must have 2 elements\n');
        end    
        % first the high pass part
        Wp_high=f0(1)+df(1)/2.0;
        Ws_high=f0(1)-df(1)/2.0;
        ind_high=[ceil(Ws_high*Nfft/fs) ceil(Wp_high*Nfft/fs)];
        mask_high=zeros(Nfft/2,1); % the mask function in freq domain
        mask_high((ind_high(2)+1):length(mask_high))=1;
        w=hanning(2*(ind_high(2)-ind_high(1))+1);
        mask_high((ind_high(1)+1):ind_high(2))=w(1:length((ind_high(1)+1):ind_high(2)));
        % now the low pass part
        Wp_low=f0(2)-df(2)/2.0; % pass point
        Ws_low=f0(2)+df(2)/2.0; % stop point
        ind_low=[ceil(Wp_low*Nfft/fs) ceil(Ws_low*Nfft/fs)]; % get the index number
        mask_low=zeros(Nfft/2,1); % the mask function in freq domain
        mask_low(1:ind_low(1))=1; % low freq side pass
        w=hanning(2*(ind_low(2)-ind_low(1))+1); % hanning window for transition
        mask_low((ind_low(1)+1):ind_low(2))=flipud(w(1:length((ind_low(1)+1):ind_low(2)))); % replace a portion of mask with hanning window
        mask=mask_high.*mask_low;
end

mask=[mask;flipud(mask)];

F_fft=fft(F,Nfft).*(mask*ones(1,n));
F_filt_temp=real(ifft(F_fft,Nfft));
F_filt=F_filt_temp(1:m,:);

%============

function res = fastif(s1, s2, s3);

if s1
	res = s2;
else
	res = s3;
end;
return;
